"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.constructZipBlobFromTreeAndPaths = exports.constructFromInput = exports.constructFromFileSystemEntries = exports.FolderTreeSchema = exports.FolderTreeFileSchema = exports.FolderTreeFolderSchema = void 0;
const jszip_1 = __importDefault(require("jszip"));
const zod_1 = require("zod");
exports.FolderTreeFolderSchema = zod_1.z.object({
    name: zod_1.z.string(),
    type: zod_1.z.literal('folder'),
    children: zod_1.z.array(zod_1.z.lazy(() => exports.FolderTreeSchema)),
    id: zod_1.z.string(),
});
exports.FolderTreeFileSchema = zod_1.z.object({
    name: zod_1.z.string(),
    type: zod_1.z.literal('file'),
    id: zod_1.z.string(),
});
exports.FolderTreeSchema = zod_1.z.discriminatedUnion('type', [
    exports.FolderTreeFolderSchema,
    exports.FolderTreeFileSchema,
]);
const constructFromFileSystemEntries = (entries) => {
    const root = {
        name: 'root',
        type: 'folder',
        children: [],
        id: 'root',
    };
    for (const entry of entries) {
        const pathParts = entry.split('/').filter(Boolean);
        let currentFolder = root;
        for (const [index, part] of Array.from(pathParts.entries())) {
            // Check if the part already exists in the current folder's children
            let existingFolder = currentFolder.children.find((child) => child.name === part);
            if (!existingFolder) {
                // If it's the last part, create a file node
                if (index === pathParts.length - 1) {
                    const fileNode = {
                        name: part,
                        type: 'file',
                        id: entry,
                    };
                    currentFolder.children.push(fileNode);
                }
                else {
                    // Create a new folder node
                    const folderNode = {
                        name: part,
                        type: 'folder',
                        children: [],
                        id: `${currentFolder.id.split('/').slice(1).join('/')}/${part}`,
                    };
                    currentFolder.children.push(folderNode);
                    existingFolder = folderNode;
                }
            }
            currentFolder = existingFolder; // Move to the next folder
        }
    }
    return root.children.length === 1 ? root.children[0] : root;
};
exports.constructFromFileSystemEntries = constructFromFileSystemEntries;
const constructFromInput = (input) => {
    return (0, exports.constructFromFileSystemEntries)(Array.from(input).map((file) => {
        if (!file.webkitRelativePath) {
            throw new Error('webkitRelativePath is not supported');
        }
        return file.webkitRelativePath;
    }));
};
exports.constructFromInput = constructFromInput;
const addFilesToZip = (folder, folderNode, files) => {
    folderNode.children.forEach((child) => {
        if (child.type === 'file') {
            folder.file(child.name, files[child.id]);
        }
        else if (child.type === 'folder') {
            const subFolder = folder.folder(child.name);
            if (!subFolder) {
                throw new Error('Failed to create folder in zip');
            }
            addFilesToZip(subFolder, child, files);
        }
    });
};
const constructZipBlobFromTreeAndPaths = (tree, files) => __awaiter(void 0, void 0, void 0, function* () {
    if (tree.type === 'file') {
        throw new Error('Cannot construct zip from file');
    }
    const zip = new jszip_1.default();
    addFilesToZip(zip, tree, files);
    return zip.generateAsync({ type: 'blob' });
});
exports.constructZipBlobFromTreeAndPaths = constructZipBlobFromTreeAndPaths;
