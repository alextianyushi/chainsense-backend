"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.constructZipFromTreeAndFileSystemPaths = exports.createWriteStreamAdapter = exports.getFiles = void 0;
const fs_1 = require("fs");
const promises_1 = __importDefault(require("fs/promises"));
const jszip_1 = __importDefault(require("jszip"));
const path_1 = __importDefault(require("path"));
const getFiles = (folderPath) => __awaiter(void 0, void 0, void 0, function* () {
    const stat = yield promises_1.default.stat(folderPath);
    if (stat.isDirectory()) {
        const files = yield promises_1.default.readdir(folderPath);
        const promises = files.map((file) => (0, exports.getFiles)(path_1.default.join(folderPath, file)));
        const allFiles = yield Promise.all(promises);
        return allFiles.flat();
    }
    else {
        return [folderPath];
    }
});
exports.getFiles = getFiles;
const createWriteStreamAdapter = (nodeWriteStream) => {
    return new WritableStream({
        write(chunk) {
            return new Promise((resolve, reject) => {
                nodeWriteStream.write(chunk, (err) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve();
                    }
                });
            });
        },
        close() {
            nodeWriteStream.end();
        },
        abort(err) {
            nodeWriteStream.destroy(err);
        },
    });
};
exports.createWriteStreamAdapter = createWriteStreamAdapter;
const addFilesFromFilepathsToZip = (folder, folderNode, files) => {
    folderNode.children.forEach((child) => {
        if (child.type === 'file') {
            const file = files[child.id];
            if (typeof file === 'string') {
                folder.file(child.name, (0, fs_1.createReadStream)(file));
            }
            else {
                folder.file(child.name, file);
            }
        }
        else if (child.type === 'folder') {
            const subFolder = folder.folder(child.name);
            if (!subFolder) {
                throw new Error('Failed to create folder in zip');
            }
            addFilesFromFilepathsToZip(subFolder, child, files);
        }
    });
};
const constructZipFromTreeAndFileSystemPaths = (tree, files) => __awaiter(void 0, void 0, void 0, function* () {
    if (tree.type === 'file') {
        throw new Error('Cannot construct zip from file');
    }
    const zip = new jszip_1.default();
    addFilesFromFilepathsToZip(zip, tree, files);
    return zip.generateAsync({ type: 'blob' });
});
exports.constructZipFromTreeAndFileSystemPaths = constructZipFromTreeAndFileSystemPaths;
