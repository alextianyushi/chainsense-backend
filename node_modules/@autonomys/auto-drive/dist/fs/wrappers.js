"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.uploadFolderFromFolderPath = exports.uploadFileFromFilepath = void 0;
const fs_1 = __importDefault(require("fs"));
const mime_types_1 = __importDefault(require("mime-types"));
const index_js_1 = require("../api/index.js");
const folderTree_js_1 = require("../api/models/folderTree.js");
const uploads_js_1 = require("../api/models/uploads.js");
const wrappers_js_1 = require("../api/wrappers.js");
const index_js_2 = require("../utils/index.js");
const misc_js_1 = require("../utils/misc.js");
const utils_js_1 = require("./utils.js");
/**
 * Uploads a file to the server with optional encryption and compression.
 *
 * This function reads a file from the specified file path, optionally encrypts it
 * using the provided password, and compresses it using the specified algorithm if requested.
 * It then uploads the file in chunks to the server, creating an upload session and
 * completing it once all chunks have been successfully uploaded.
 *
 * @param {AutoDriveApi} api - The API instance used to send requests.
 * @param {string} filePath - The path to the file to be uploaded.
 * @param {UploadFileOptions} options - Options for the upload process.
 * @param {string} [options.password] - The password for encryption (optional).
 * @param {boolean} [options.compression=true] - Whether to compress the file (optional).
 * @param {number} [uploadChunkSize] - The size of each chunk to upload (optional).
 * @returns {PromisedObservable<UploadFileStatus>} - An observable that emits the upload status.
 * @throws {Error} - Throws an error if the upload fails at any stage.
 */
const uploadFileFromFilepath = (api, filePath, options = {}, uploadChunkSize) => {
    const { password = undefined, compression = true, onProgress } = options;
    const name = filePath.split('/').pop();
    return (0, wrappers_js_1.uploadFile)(api, {
        read: () => fs_1.default.createReadStream(filePath),
        name,
        mimeType: mime_types_1.default.lookup(name) || undefined,
        size: fs_1.default.statSync(filePath).size,
    }, {
        password,
        compression,
        onProgress,
    }, uploadChunkSize);
};
exports.uploadFileFromFilepath = uploadFileFromFilepath;
/**
 * Uploads an entire folder to the server.
 *
 * This function retrieves all files within the specified folder,
 * constructs a file tree representation, and initiates the upload
 * process. It also handles optional compression and encryption of the files during
 * the upload.
 *
 * If a password is provided, the files will be zipped before uploading.
 *
 * @param {AutoDriveApi} api - The API instance used to send requests.
 * @param {string} folderPath - The path of the folder to be uploaded.
 * @param {Object} options - Optional parameters for the upload.
 * @param {number} [options.uploadChunkSize] - The size of each chunk to be uploaded.
 * @param {string} [options.password] - An optional password for encrypting the files.
 * @returns {Promise<PromisedObservable<UploadFileStatus | UploadFolderStatus>>} - A promise that resolves to an observable that tracks the upload progress.
 * @throws {Error} - Throws an error if the upload fails at any stage.
 */
const uploadFolderFromFolderPath = (api_1, folderPath_1, ...args_1) => __awaiter(void 0, [api_1, folderPath_1, ...args_1], void 0, function* (api, folderPath, { uploadChunkSize, password, onProgress, } = {}) {
    const files = yield (0, utils_js_1.getFiles)(folderPath);
    const fileTree = (0, folderTree_js_1.constructFromFileSystemEntries)(files);
    if (password) {
        const filesMap = Object.fromEntries(files.map((file) => [file, file]));
        const zipBlob = yield (0, utils_js_1.constructZipFromTreeAndFileSystemPaths)(fileTree, filesMap);
        const name = folderPath.split('/').pop();
        return (0, wrappers_js_1.uploadFile)(api, {
            read: () => (0, index_js_2.fileToIterable)(zipBlob),
            name: `${name}.zip`,
            mimeType: 'application/zip',
            size: zipBlob.size,
        }, {
            password,
            compression: true,
            onProgress: (progressInPercentage) => {
                onProgress === null || onProgress === void 0 ? void 0 : onProgress((0, misc_js_1.progressToPercentage)(progressInPercentage, zipBlob.size));
            },
        });
    }
    const folderUpload = yield index_js_1.apiCalls.createFolderUpload(api, {
        fileTree,
        uploadOptions: {
            compression: {
                algorithm: uploads_js_1.CompressionAlgorithm.ZLIB,
                level: 9,
            },
        },
    });
    const genericFiles = files.map((file) => ({
        read: () => fs_1.default.createReadStream(file),
        name: file.split('/').pop(),
        mimeType: mime_types_1.default.lookup(file.split('/').pop()) || undefined,
        size: fs_1.default.statSync(file).size,
        path: file,
    }));
    const totalSize = genericFiles.reduce((acc, file) => acc + file.size, 0);
    let progress = 0;
    for (const file of genericFiles) {
        yield (0, wrappers_js_1.uploadFileWithinFolderUpload)(api, folderUpload.id, file, uploadChunkSize, {
            onProgress: (uploadedBytes) => {
                onProgress === null || onProgress === void 0 ? void 0 : onProgress((0, misc_js_1.progressToPercentage)(progress + uploadedBytes, totalSize));
            },
        });
        progress += file.size;
    }
    const result = yield index_js_1.apiCalls.completeUpload(api, { uploadId: folderUpload.id });
    return result.cid;
});
exports.uploadFolderFromFolderPath = uploadFolderFromFolderPath;
